---
name: evolve
description: >
  自我進化 Agent：給定目標，自主學習並迭代改進直到完成。
  觸發詞：evolve、進化、自我學習、迭代改進、達成目標。
  適用於：複雜任務自動完成、需要學習新技能的任務、多步驟迭代改進。
allowed-tools: Bash, Read, Write, Edit, Glob, Grep, WebSearch, WebFetch, Task, AskUserQuestion, TodoWrite
version: 2.1.0
---

# Self-Evolving Agent v2.1

> 給定目標 → 評估能力 → 習得技能 → 執行 → 診斷 → 多策略重試 → 結構化記憶 → 直到成功

## 核心理念

```
┌─────────────────────────────────────────────────────────────────┐
│                  Self-Evolving Loop v2.0                       │
│                                                                 │
│    ┌──────────┐                                                │
│    │   目標   │                                                │
│    └────┬─────┘                                                │
│         ↓                                                       │
│    ┌──────────────┐                                            │
│    │ 能力邊界評估 │  ← NEW: 先評估自己會什麼、缺什麼           │
│    └──────┬───────┘                                            │
│           ↓                                                     │
│    ┌──────────────┐     ┌──────────────┐                       │
│    │ Skill 習得   │ ──→ │   驗證學習   │  ← NEW: 整合 skillpkg │
│    │ (recommend/  │     │   (簡單測試) │                       │
│    │  install)    │     └──────┬───────┘                       │
│    └──────────────┘            ↓                               │
│         ↓                                                       │
│    ┌──────────┐     ┌──────────┐     ┌──────────────┐          │
│    │   Plan   │ ──→ │    Do    │ ──→ │    Check     │          │
│    │  (規劃)  │     │  (執行)  │     │  (失敗診斷)  │ ← NEW    │
│    └──────────┘     └──────────┘     └──────┬───────┘          │
│         ↑                                    │                  │
│         │           ┌──────────────┐         │                  │
│         └────────── │ 多策略選擇   │ ←───────┘  ← NEW          │
│                     │ (策略池機制) │                            │
│                     └──────┬───────┘                            │
│                            │                                    │
│                     ┌──────▼───────┐                            │
│                     │ 結構化經驗   │  ← NEW: 可檢索的經驗格式  │
│                     │   Memory     │                            │
│                     └──────────────┘                            │
│                                                                 │
│    重複直到：目標達成 或 達到最大迭代次數                       │
└─────────────────────────────────────────────────────────────────┘
```

## v2.0 新增能力

| 能力 | 說明 |
|------|------|
| **Skill 自動習得** | 整合 skillpkg MCP，自動搜尋/安裝/載入 skills |
| **失敗模式診斷** | 分類失敗類型，針對性處理 |
| **能力邊界感知** | 執行前評估自己會什麼、缺什麼 |
| **多策略嘗試** | 不重複同一策略，從策略池選擇 |
| **結構化經驗** | 可檢索的經驗格式，支援經驗傳承 |
| **學習驗證** | 安裝 skill 後先驗證再應用 |

## 使用方式

```
觸發詞：/evolve [目標描述]

範例：
/evolve 建立一個能自動生成遊戲道具圖片的 ComfyUI 工作流程
/evolve 優化這段程式碼的效能，目標是降低 50% 執行時間
/evolve 為這個專案建立完整的測試覆蓋率達到 80%
```

## 執行流程

### Phase 1: 目標分析

```markdown
0. 目標明確性檢查（優先執行）
   ┌─────────────────────────────────────────────────────────┐
   │  檢查項目：                                             │
   │  □ 有具體的成功標準嗎？                                │
   │  □ 有可量化的驗收條件嗎？                              │
   │  □ 範圍是否明確？                                      │
   │  □ 有技術/資源約束嗎？                                 │
   │  □ 有時間/品質偏好嗎？                                 │
   └─────────────────────────────────────────────────────────┘

   若有 ≥2 項不明確 → 使用 AskUserQuestion 確認
   若只有 1 項不明確 → 用【假設】補齊，列出假設內容
   若全部明確 → 直接進入目標解析

1. 解析目標
   - 最終成功標準是什麼？
   - 如何驗證目標達成？
   - 有哪些約束條件？

2. 分解子目標
   - 將大目標拆成可執行的步驟
   - 識別依賴關係
   - 設定每個步驟的驗收標準

3. 評估現有能力
   - 需要哪些技能/工具？
   - 哪些已具備？哪些需要學習？
```

### Phase 1.5: 能力邊界評估 (NEW)

執行任務前，先進行自我能力評估。以下是評估時使用的**思考框架**：

```yaml
# ========================================
# 能力評估思考框架（範例，實際內容依任務而定）
# ========================================
task: "[分析用戶的任務後填入]"

capability_assessment:
  # 確定會的（根據實際情況填寫）
  confident_in:
    - skill: "[技能名稱]"
      level: "熟練 / 基本 / 略知"

  # 不確定的
  uncertain_about:
    - skill: "[技能名稱]"
      reason: "[為什麼不確定]"

  # 確定需要學習的
  definitely_need:
    - "[需要的技能或知識]"

  # 行動計劃
  action_plan:
    - step: "[下一步行動]"
      tool: "[使用的工具]"
```

**範例**（當任務是「用 ComfyUI 生成遊戲道具」時）：
```yaml
task: "用 ComfyUI 生成遊戲道具圖片"

capability_assessment:
  confident_in:
    - skill: "Python 程式設計"
      level: "熟練"
  uncertain_about:
    - skill: "ComfyUI 工作流程"
      reason: "從未使用過"
  definitely_need:
    - "ComfyUI 節點操作知識"
  action_plan:
    - step: "搜尋 ComfyUI 相關 skill"
      tool: "recommend_skill"
```

**評估流程：**
```
任務分析 → 列出需要的能力 → 自評每項能力
    ↓
┌───────────────────────────────────────────┐
│  對於每項「不確定」或「確定需要」的能力：  │
│                                           │
│  1. cipher_memory_search 查找過去經驗     │
│  2. 沒有經驗 → recommend_skill 搜尋       │
│  3. 找到 skill → install + verify        │
│  4. 驗證通過 → 加入 confident_in         │
└───────────────────────────────────────────┘
    ↓
所有關鍵能力都在 confident_in → 開始執行
```

### 目標確認問卷（使用 AskUserQuestion）

當目標不明確時，**一次收齊**關鍵資訊：

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  ❓ 需要確認目標細節                                           │
│                                                                 │
│  您的目標：[用戶輸入的原始目標]                                 │
│                                                                 │
│  請幫我確認以下幾點：                                           │
│                                                                 │
│  1. 成功標準                                                    │
│     □ 能正常運作即可                                           │
│     □ 需要特定效能指標（請說明）                               │
│     □ 需要通過測試/驗收條件（請說明）                          │
│                                                                 │
│  2. 範圍限制                                                    │
│     □ 只處理核心功能                                           │
│     □ 需要完整實作（含邊界情況）                               │
│     □ 需要考慮擴展性                                           │
│                                                                 │
│  3. 品質 vs 速度                                                │
│     □ 快速完成優先（可接受後續優化）                           │
│     □ 品質優先（寧可慢也要做好）                               │
│     □ 平衡                                                     │
│                                                                 │
│  4. 其他約束                                                    │
│     □ 無特別限制                                               │
│     □ 有（請說明：技術棧/相容性/資源限制）                     │
└─────────────────────────────────────────────────────────────────┘
```

### 不明確目標範例

| 用戶輸入 | 缺少的資訊 | 需要確認 |
|----------|------------|----------|
| 「優化效能」 | 優化什麼？目標數值？ | ✅ |
| 「做一個網站」 | 什麼功能？什麼風格？ | ✅ |
| 「修好這個 bug」 | bug 現象？預期行為？ | ✅ |
| 「把這段程式碼重構成 TypeScript，要有型別定義」 | 全部明確 | ❌ |
| 「建立登入功能，要有 JWT 和刷新 token」 | 全部明確 | ❌ |

### Phase 2: 執行循環（PDCA）

每個子目標執行以下循環：

```markdown
┌─ Plan（規劃）─────────────────────────────────────────┐
│  - 制定具體執行計劃                                   │
│  - 預測可能的問題                                     │
│  - 準備備選方案                                       │
└───────────────────────────────────────────────────────┘
                          ↓
┌─ Do（執行）───────────────────────────────────────────┐
│  - 按計劃執行                                         │
│  - 記錄執行過程                                       │
│  - 收集中間結果                                       │
└───────────────────────────────────────────────────────┘
                          ↓
┌─ Check（評估）────────────────────────────────────────┐
│  - 結果是否符合預期？                                 │
│  - 如果失敗，分析原因                                 │
│  - 評估：完全成功 / 部分成功 / 失敗                  │
└───────────────────────────────────────────────────────┘
                          ↓
┌─ Act（改進）──────────────────────────────────────────┐
│  如果成功：                                           │
│  - 記錄成功經驗到 Memory                              │
│  - 進入下一個子目標                                   │
│                                                       │
│  如果失敗：                                           │
│  - 反思：為什麼失敗？                                 │
│  - 學習：需要什麼新知識/技能？                       │
│  - 搜索：查找相關資料                                 │
│  - 更新：改進執行策略                                 │
│  - 重試：帶著新知識重新執行                           │
└───────────────────────────────────────────────────────┘
```

### Phase 3: 反思與學習（Reflexion）

```markdown
每次失敗後的反思流程：

1. 失敗分析
   - 錯誤類型是什麼？（邏輯/語法/環境/理解）
   - 根本原因是什麼？
   - 是否遺漏了什麼？

2. 知識補充
   - 需要學習什麼？
   - 使用 WebSearch 搜索相關資料
   - 閱讀文檔或範例

3. 策略調整
   - 原策略哪裡有問題？
   - 新策略是什麼？
   - 如何避免同樣的錯誤？

4. 記憶更新
   - 將學到的經驗寫入 Memory
   - 格式：[情境] → [錯誤] → [解決方案]
```

### Phase 4: 記憶系統 (Cipher MCP)

```markdown
雙記憶架構 (Cipher Memory Layer)：

┌─ System 1: 知識記憶（Knowledge Memory）──────────────┐
│  - Codebase 知識、業務邏輯                            │
│  - 成功的解決方案、最佳實踐                           │
│  - 過去的互動經驗                                     │
│  工具：cipher_extract_and_operate_memory              │
│  搜尋：cipher_memory_search                           │
└───────────────────────────────────────────────────────┘

┌─ System 2: 反思記憶（Reflection Memory）─────────────┐
│  - AI 推理步驟和問題解決模式                          │
│  - 策略演進記錄                                       │
│  - 持續改進的代碼生成                                 │
│  工具：cipher_store_reasoning_memory                  │
│  搜尋：cipher_search_reasoning_patterns               │
└───────────────────────────────────────────────────────┘

┌─ 情境記憶（Session Memory）──────────────────────────┐
│  - 當前執行的上下文                                   │
│  - 本次迭代的嘗試記錄                                 │
│  - 臨時數據                                           │
│  儲存：對話上下文                                     │
└───────────────────────────────────────────────────────┘

Cipher 優勢：
✓ 跨 IDE 同步（Cursor ↔ VS Code ↔ Claude Code）
✓ 團隊共享記憶（Workspace Memory）
✓ 自動學習開發模式
✓ 零配置即用
```

## 自我進化機制

### 1. 技能習得（整合 skillpkg MCP）(ENHANCED)

```markdown
當遇到無法完成的任務時：

┌─────────────────────────────────────────────────────────────────┐
│  技能習得流程 v2.0                                              │
│                                                                 │
│  1. 識別技能缺口                                                │
│     - 「我無法完成 X 因為我不知道如何 Y」                       │
│     - 區分：缺「知識」還是缺「工具」                            │
│                                                                 │
│  2. 搜尋已有經驗                                                │
│     cipher_memory_search({ query: "Y" })                        │
│     - 有經驗 → 直接應用                                         │
│     - 無經驗 → 繼續步驟 3                                       │
│                                                                 │
│  3. 搜尋可用 Skill                                              │
│     recommend_skill({ query: "Y", criteria: "popular" })        │
│     - 評估推薦的 skill 是否適用                                 │
│     - 查看 alternatives 比較選擇                                │
│                                                                 │
│  4. 安裝 Skill                                                  │
│     install_skill({ source: "best-skill-name" })                │
│     - 從 Registry / GitHub / URL 安裝                           │
│                                                                 │
│  5. 載入並學習                                                  │
│     load_skill({ id: "best-skill-name" })                       │
│     - 仔細閱讀 instructions                                     │
│     - 理解使用方式和限制                                        │
│                                                                 │
│  6. 驗證學習 ← NEW                                              │
│     - 用簡單任務測試是否學會                                    │
│     - 成功 → 應用到實際任務                                     │
│     - 失敗 → 重新學習或換 skill                                 │
│                                                                 │
│  7. 記錄學習經驗                                                │
│     cipher_extract_and_operate_memory({                         │
│       content: "情境 + skill + 效果"                            │
│     })                                                          │
│     cipher_store_reasoning_memory({                             │
│       pattern: "學到的推理模式"                                 │
│     })                                                          │
└─────────────────────────────────────────────────────────────────┘
```

**Skill 習得範例：**
```
任務：用 ComfyUI 生成遊戲道具

1. 識別缺口：不會 ComfyUI
2. cipher_memory_search("ComfyUI") → 無結果
3. recommend_skill({ query: "ComfyUI game assets" })
   → 推薦：comfyui-expert (⭐4.9, 2.1k downloads)
   → 理由：專門處理遊戲素材，支援透明背景
4. install_skill({ source: "comfyui-expert" })
   → 安裝成功
5. load_skill({ id: "comfyui-expert" })
   → 學習 instructions
6. 驗證：生成一張簡單測試圖
   → 成功！
7. cipher_extract_and_operate_memory 記錄經驗
   cipher_store_reasoning_memory 記錄推理模式
```

### 2. 失敗模式診斷 (NEW)

失敗時先分類，再針對性處理：

```
┌─────────────────────────────────────────────────────────────────┐
│  失敗類型分類表                                                 │
│                                                                 │
│  類型 A: 知識缺口                                               │
│  ├─ 症狀：不知道怎麼做、沒見過這種問題                         │
│  ├─ 診斷：缺少領域知識或工具使用經驗                           │
│  └─ 處方：recommend_skill → install → learn                    │
│                                                                 │
│  類型 B: 執行錯誤                                               │
│  ├─ 症狀：知道怎麼做但做錯了、語法錯誤、參數錯誤               │
│  ├─ 診斷：粗心或理解不完整                                     │
│  └─ 處方：重新閱讀文檔、仔細檢查參數                           │
│                                                                 │
│  類型 C: 環境問題                                               │
│  ├─ 症狀：依賴缺失、版本不符、權限不足                         │
│  ├─ 診斷：環境配置問題                                         │
│  └─ 處方：修復環境、安裝依賴、切換版本                         │
│                                                                 │
│  類型 D: 策略錯誤                                               │
│  ├─ 症狀：方法正確但不適合當前情境                             │
│  ├─ 診斷：選錯了解決方案                                       │
│  └─ 處方：切換到策略池中的其他策略                             │
│                                                                 │
│  類型 E: 資源限制                                               │
│  ├─ 症狀：記憶體不足、API 限制、時間超時                       │
│  ├─ 診斷：硬體或服務限制                                       │
│  └─ 處方：優化資源使用、分批處理、換用輕量方案                 │
└─────────────────────────────────────────────────────────────────┘
```

**診斷流程：**
```
失敗發生 → 收集錯誤訊息 → 分類失敗類型 → 選擇對應處方 → 執行修復
     │
     └─ 記錄到 cipher_extract_and_operate_memory（避免重複踩坑）
```

### 3. 多策略機制 (NEW)

不重複嘗試同一個失敗策略，維護策略池進行智慧選擇：

```markdown
策略池結構：
┌─────────────────────────────────────────────────────────────────┐
│  strategy_pool:                                                 │
│    current_task: "批量生成遊戲道具圖片"                         │
│                                                                 │
│    available_strategies:                                        │
│      - id: "s1"                                                 │
│        name: "ComfyUI + RemBG"                                  │
│        status: "untried"                                        │
│        priority: 1                                              │
│        requirements: ["comfyui", "rembg"]                       │
│                                                                 │
│      - id: "s2"                                                 │
│        name: "Stable Diffusion API + 透明背景模型"               │
│        status: "untried"                                        │
│        priority: 2                                              │
│        requirements: ["sd-api-key"]                             │
│                                                                 │
│      - id: "s3"                                                 │
│        name: "DALL-E + 後處理去背"                               │
│        status: "untried"                                        │
│        priority: 3                                              │
│        requirements: ["openai-key"]                             │
│                                                                 │
│    tried_strategies:                                            │
│      - id: "s1"                                                 │
│        result: "failed"                                         │
│        reason: "ComfyUI 安裝失敗"                               │
│        do_not_retry_until: "環境問題解決"                       │
└─────────────────────────────────────────────────────────────────┘

策略選擇邏輯：
1. 從 available_strategies 按 priority 排序
2. 跳過 status = "failed" 且 do_not_retry_until 未滿足的
3. 選擇第一個可行的策略
4. 如果所有策略都失敗 → 詢問用戶或搜尋新策略
```

**策略追蹤格式：**
```json
{
  "strategy": "使用 ComfyUI 批量生成圖片",
  "context": "遊戲道具生成",
  "attempts": 5,
  "successes": 4,
  "failures": 1,
  "failure_reasons": ["模型未載入"],
  "improvements": ["先檢查模型是否存在"],
  "success_rate": 0.8
}
```

### 4. 結構化經驗格式 (NEW)

經驗必須用可檢索的格式儲存，方便未來查詢：

```yaml
# 結構化經驗模板
experience:
  id: "exp-20250102-001"
  type: "learning" | "solution" | "failure" | "optimization"

  # 情境（用於匹配）
  context:
    task_type: "圖片生成"
    domain: "ComfyUI"
    keywords: ["透明背景", "遊戲素材", "批量"]

  # 問題描述
  problem:
    description: "生成的圖片有白色背景"
    symptoms: ["PNG 有背景", "不透明"]
    error_messages: []

  # 解決方案
  solution:
    approach: "使用 RemBG 節點移除背景"
    steps:
      - "安裝 ComfyUI-Manager"
      - "搜尋並安裝 RemBG 節點"
      - "在工作流程最後加入 RemBG"
    code_snippets: []
    resources: ["https://..."]

  # 驗證結果
  verification:
    tested: true
    success: true
    notes: "需要足夠 GPU 記憶體"

  # 元資料
  metadata:
    created_at: "2025-01-02"
    confidence: "high"
    reuse_count: 0
```

**經驗儲存範例：**
```python
await memory_archive({
    "content": """
    ## 經驗：ComfyUI 生成透明背景圖片

    **情境**: 遊戲素材生成、需要 PNG 透明背景
    **問題**: 預設輸出有白色背景
    **解法**: 使用 RemBG 節點後處理
    **驗證**: ✅ 成功
    **注意**: 需要 4GB+ GPU 記憶體
    """,
    "type": "solution",
    "tags": ["comfyui", "透明背景", "rembg", "遊戲素材"]
})
```

### 5. 學習驗證流程 (NEW)

安裝新 skill 後，必須驗證真的學會才能應用：

```
┌─────────────────────────────────────────────────────────────────┐
│  學習驗證流程                                                   │
│                                                                 │
│  1. 安裝 Skill                                                  │
│     install_skill({ source: "comfyui-expert" })                 │
│                                                                 │
│  2. 載入 Instructions                                           │
│     load_skill({ id: "comfyui-expert" })                        │
│                                                                 │
│  3. 設計簡單驗證任務                                            │
│     ┌─────────────────────────────────────┐                    │
│     │  驗證任務應該：                      │                    │
│     │  • 範圍小、可快速完成               │                    │
│     │  • 涵蓋核心能力                     │                    │
│     │  • 有明確的成功標準                 │                    │
│     └─────────────────────────────────────┘                    │
│                                                                 │
│  4. 執行驗證                                                    │
│     ┌─────────────────────────────────────┐                    │
│     │  例：生成一張簡單的測試圖片          │                    │
│     │      檢查是否符合預期格式           │                    │
│     └─────────────────────────────────────┘                    │
│                                                                 │
│  5. 評估結果                                                    │
│     ✅ 成功 → 加入 confident_in，繼續主任務                    │
│     ❌ 失敗 → 重新學習或嘗試其他 skill                         │
└─────────────────────────────────────────────────────────────────┘
```

**驗證範例：**
```
Skill: comfyui-expert
驗證任務: 生成一張 256x256 的藍色方塊圖片
成功標準: 輸出 PNG、尺寸正確、顏色正確
結果: ✅ 成功
→ 確認學會 ComfyUI 基本操作，繼續主任務
```

### 6. 策略進化

```markdown
追蹤每種策略的成功率：

策略選擇邏輯：
- 優先選擇成功率高的策略
- 失敗時切換到備選策略（參考多策略機制）
- 新情境時嘗試類比已知策略
- 所有策略都失敗時，搜尋新策略或詢問用戶
```

### 7. Prompt 自我優化

```markdown
根據執行結果調整自己的 Prompt：

原始 Prompt：
「生成一個遊戲道具圖片」

失敗後反思：
「生成的圖片背景不透明，不適合遊戲使用」

優化後 Prompt：
「生成一個遊戲道具圖片，要求：
 - 透明背景（PNG 格式）
 - 256x256 解析度
 - 卡通風格」

儲存優化後的 Prompt 模板到記憶中
```

## 停止條件

```markdown
Agent 在以下情況停止：

✅ 成功條件：
   - 所有子目標完成
   - 驗收標準通過

❌ 失敗條件：
   - 達到最大迭代次數（預設 10 次）
   - 連續 3 次相同錯誤
   - 用戶手動中止

⚠️ 暫停條件：
   - 需要用戶決策
   - 需要外部資源
   - 風險操作需確認
```

## 與用戶的互動

```markdown
進度報告（每個主要步驟後）：
┌─────────────────────────────────────────────────────┐
│  📊 進度更新                                        │
│                                                     │
│  目標：建立 ComfyUI 工作流程                        │
│  進度：███████░░░ 70%                               │
│                                                     │
│  ✅ 已完成：                                        │
│     - 安裝 ComfyUI                                  │
│     - 下載基礎模型                                  │
│     - 建立基本工作流程                              │
│                                                     │
│  🔄 進行中：                                        │
│     - 加入 LoRA 支援                                │
│                                                     │
│  ⏳ 待完成：                                        │
│     - 批量生成功能                                  │
│     - 輸出格式優化                                  │
│                                                     │
│  📝 學習記錄：                                      │
│     - 發現：LoRA 需要特定節點                       │
│     - 解決：安裝 ComfyUI-Manager                    │
└─────────────────────────────────────────────────────┘

需要確認時：
┌─────────────────────────────────────────────────────┐
│  ❓ 需要您的決定                                    │
│                                                     │
│  我嘗試了兩種方法都失敗了：                         │
│  1. 直接載入模型 → 記憶體不足                       │
│  2. 使用低精度模型 → 品質不佳                       │
│                                                     │
│  建議選項：                                         │
│  A. 使用雲端 GPU（需要費用）                        │
│  B. 降低輸出解析度（512→256）                       │
│  C. 換用更小的模型                                  │
│                                                     │
│  您希望怎麼做？                                     │
└─────────────────────────────────────────────────────┘
```

## 實作注意事項

### 安全機制

```markdown
1. 迭代上限
   - 防止無限循環
   - 預設最大 10 次嘗試

2. 範圍限制
   - 不執行危險操作（rm -rf 等）
   - 重要操作需用戶確認

3. 資源監控
   - 追蹤 API 呼叫次數
   - 避免過度消耗

4. 回滾機制
   - 每次重大變更前備份
   - 失敗時可以回滾
```

### 效能優化

```markdown
1. 快取成功經驗
   - 避免重複學習相同內容

2. 平行執行
   - 獨立的子任務可平行處理

3. 早期失敗檢測
   - 快速識別不可行的方向

4. 漸進式複雜度
   - 先嘗試簡單方案
   - 失敗後再嘗試複雜方案
```

## 與現有系統整合

### 整合 Cipher Memory (MCP)

```python
# 儲存知識記憶 (System 1)
await mcp__cipher__cipher_extract_and_operate_memory({
    "content": """
    ## 學習記錄：ComfyUI LoRA 載入

    情境：需要在 ComfyUI 中使用自訓練的 LoRA

    問題：直接使用 Load LoRA 節點失敗

    解決方案：
    1. 確認 LoRA 檔案在 models/loras/ 目錄
    2. 使用 LoraLoader 節點（不是 Load LoRA）
    3. 設定 strength_model 和 strength_clip

    驗證：成功載入並生成圖片
    """
})

# 搜尋知識記憶
results = await mcp__cipher__cipher_memory_search({
    "query": "ComfyUI LoRA 載入問題"
})

# 儲存推理模式 (System 2)
await mcp__cipher__cipher_store_reasoning_memory({
    "pattern": "遇到節點載入失敗時，先檢查檔案路徑和節點類型是否正確"
})

# 搜尋推理模式
patterns = await mcp__cipher__cipher_search_reasoning_patterns({
    "query": "節點載入失敗"
})
```

**Cipher 工具對照表：**
| 舊工具 (claude-dev-memory) | 新工具 (Cipher) |
|---------------------------|-----------------|
| memory_archive | cipher_extract_and_operate_memory |
| memory_search | cipher_memory_search |
| memory_update | cipher_extract_and_operate_memory |
| - | cipher_store_reasoning_memory (新增) |
| - | cipher_search_reasoning_patterns (新增) |

### 整合 PAL 工具

```python
# 深度思考複雜問題
await mcp__pal__thinkdeep({
    "step": "分析為什麼批量生成會失敗",
    "findings": "記憶體在第 5 張圖時耗盡",
    "hypothesis": "沒有正確釋放 GPU 記憶體",
    ...
})

# 多模型驗證方案
await mcp__pal__consensus({
    "step": "評估三種解決方案的可行性",
    "models": [
        {"model": "gpt-5", "stance": "for"},
        {"model": "gemini-2.5-pro", "stance": "against"}
    ],
    ...
})
```

## 範例執行過程

```markdown
用戶：/evolve 建立一個能批量生成遊戲道具圖片的系統

Agent：
📋 目標分析完成

目標：建立批量遊戲道具圖片生成系統
驗收標準：
- 能一次生成 10+ 張道具圖片
- 風格一致
- 背景透明
- 解析度 512x512

子目標：
1. ✅ 確認 ComfyUI 環境
2. 🔄 建立基礎工作流程
3. ⏳ 加入風格控制（LoRA）
4. ⏳ 實作批量生成
5. ⏳ 輸出格式處理

---

🔄 執行子目標 2：建立基礎工作流程

Plan：建立 text-to-image 基本流程
Do：[建立工作流程...]
Check：❌ 失敗 - 生成的圖片有背景

📝 反思：
- 問題：預設輸出不是透明背景
- 原因：沒有使用適當的模型和後處理
- 學習需求：如何生成透明背景圖片

🔍 搜索中...
[WebSearch: "ComfyUI transparent background PNG game assets"]

📚 學到：
- 需要使用 Remove Background 節點
- 或使用專門的 icon 生成模型

Act：更新策略，加入背景移除步驟

---

🔄 重試子目標 2

Plan：加入 RemBG 節點移除背景
Do：[更新工作流程...]
Check：✅ 成功 - 背景已透明

💾 儲存經驗到記憶

---

繼續下一個子目標...
```

## 相關資源

- [Reflexion Paper](https://arxiv.org/abs/2303.11366)
- [OpenAI Self-Evolving Agents Cookbook](https://cookbook.openai.com/examples/partners/self_evolving_agents/autonomous_agent_retraining)
- [Andrew Ng - Agentic Design Patterns](https://www.deeplearning.ai/the-batch/agentic-design-patterns-part-2-reflection/)
- [AutoPDL Paper](https://arxiv.org/abs/2504.04365)
