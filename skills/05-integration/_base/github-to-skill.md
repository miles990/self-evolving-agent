# GitHub → Skill 封裝策略

> 判斷何時適合將 GitHub 開源項目封裝成 Skill，以及如何執行

## 核心洞見

**GitHub 上有無數好工具，但普通人用不了。** 原因：
- 沒有 GUI，只有命令行
- 需要配置環境（Python、Node、Docker 等）
- 文檔晦澀難懂
- 光是安裝就能卡死大多數人

**解法**：用 AI + Skill 橋接這個鴻溝。把開源項目的能力「翻譯」成自然語言介面。

## 核心判斷原則

> **只要能讓工具變得更好用，就該封裝。**

### 🎯 四維度快速判斷

在決定是否封裝之前，問自己這四個問題：

| 維度 | 判斷問題 | 封裝價值 |
|------|----------|----------|
| ⚡ **效率** | 能減少我的處理時間嗎？ | 省時 = 值得 |
| 🎓 **專業** | 能增強專業能力嗎？ | 增強 = 值得 |
| 🔧 **完整** | 能提供更完整的功能嗎？ | 補足 = 值得 |
| ✨ **品質** | 能讓它成為更好的工具嗎？ | 提升 = 值得 |
| 🎨 **體驗** | 能提供更好的使用介面嗎？ | 好用 = 值得 |
| 📚 **學習** | 能從中獲得專業知識嗎？ | 學到 = 值得 |

**任一維度有明確提升 → 適合封裝**

```
┌─────────────────────────────────────────────────────────────────┐
│  快速決策公式                                                   │
│                                                                 │
│  封裝價值 = 效率 + 專業 + 完整 + 品質 + 體驗 + 學習             │
│                                                                 │
│  只要 封裝價值 > 封裝成本（約 10-30 分鐘）→ ✅ 封裝             │
│                                                                 │
│  💡 即使只為了「學習」這一個維度，也值得封裝                    │
└─────────────────────────────────────────────────────────────────┘
```

### ✅ 適合封裝的情境

| 情境 | 說明 | 維度對應 | 範例 |
|------|------|----------|------|
| **重複使用** | 你會多次用到這個工具 | ⚡ 效率 | yt-dlp 下載視頻、FFmpeg 轉檔 |
| **操作繁瑣** | 每次使用需要記住複雜參數 | ⚡ 效率 | ImageMagick 圖片處理 |
| **環境依賴重** | 需要特定環境才能運行 | 🔧 完整 | Pandoc 文檔轉換 |
| **學習曲線陡** | 功能強大但難以上手 | 🎓 專業 | Blender CLI、ComfyUI |
| **跨平台需求** | 需要在不同環境使用同樣功能 | 🔧 完整 | 格式轉換工具 |
| **專業領域** | 涉及專業知識才能正確使用 | 🎓 專業 | 量化交易、音頻處理 |
| **可優化空間** | 原工具不夠好用，可改進 | ✨ 品質 | 整合多工具統一入口 |
| **介面不友善** | CLI 難用、輸出難讀、錯誤訊息不清 | 🎨 體驗 | 美化輸出、智能提示 |
| **流程可簡化** | 多步驟可合併成一步 | 🎨 體驗 | 「一句話完成」封裝 |
| **缺少引導** | 不知道從何開始 | 🎨 體驗 | 互動式配置、範例驅動 |
| **知識密集** | 項目包含大量專業知識 | 📚 學習 | 量化交易、ML 框架 |
| **最佳實踐** | 代碼展示了領域最佳實踐 | 📚 學習 | 架構模式、設計模式 |
| **新技術探索** | 想學習某個新技術/領域 | 📚 學習 | 封裝過程即是學習過程 |

### ❌ 不適合封裝的情境

| 情境 | 說明 | 更好的做法 |
|------|------|-----------|
| **一次性使用** | 只會用一次的工具 | 直接讓 AI 執行 |
| **已有 Skill** | Skill 庫已有類似功能 | 優先使用現有 Skill |
| **需要 GUI** | 核心功能依賴圖形界面 | 提供操作指引 |
| **即時互動** | 需要持續人機互動 | 考慮 MCP Server |
| **頻繁更新** | API/用法經常變動 | 直接查文檔 |

### 🔶 條件性適合

| 情境 | 條件 | 建議 |
|------|------|------|
| **大型項目** | 只需要部分功能 | 封裝常用子集 |
| **需要認證** | 涉及 API Key/Token | 封裝流程，認證交給用戶 |
| **有競品** | 多個工具做類似的事 | 封裝最成熟的那個 |

### 🧩 進階策略：分解重組

> **不只是封裝，而是拆解後重新設計**

當一個大型開源項目過於龐雜時，可以：

```
┌─────────────────────────────────────────────────────────────────┐
│  分解重組策略                                                   │
│                                                                 │
│  原始項目（例如 FFmpeg）                                        │
│  └─ 功能龐雜、參數海量、學習曲線陡                              │
│                                                                 │
│  分解成元件：                                                   │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐            │
│  │ 視頻轉換 │  │ 音頻提取 │  │ 壓縮優化 │  │ 格式偵測 │            │
│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘            │
│       │            │            │            │                 │
│       └────────────┴────────────┴────────────┘                 │
│                          ↓                                     │
│  重組成專用 Skill：                                             │
│  ┌─────────────────────────────────────────────────────┐       │
│  │  media-converter                                     │       │
│  │  「把這個視頻轉成 MP4」→ 自動選擇最佳參數           │       │
│  │  「提取音頻」→ 自動偵測格式、保持品質               │       │
│  │  「壓縮到 10MB 以下」→ 智能平衡畫質和大小           │       │
│  └─────────────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────────────┘
```

**分解重組的優勢**：

| 優勢 | 說明 |
|------|------|
| **簡化介面** | 隱藏複雜參數，暴露最常用功能 |
| **智能默認** | 根據情境自動選擇最佳配置 |
| **組合靈活** | 不同元件可自由搭配 |
| **維護容易** | 單一元件壞了不影響其他 |
| **漸進擴展** | 需要時再加入新元件 |
| **UX 重塑** | 重新設計使用體驗，不受原工具限制 |

**適用場景**：

```yaml
適合分解重組:
  - 功能過多: 只用到 20% 功能的大型項目
  - 參數複雜: 參數組合爆炸的工具（如 FFmpeg、ImageMagick）
  - 跨領域: 涉及多個專業領域的項目
  - 工作流: 需要串接多個步驟的任務

不適合分解重組:
  - 功能緊密耦合: 拆開會失去意義
  - 簡單工具: 本身就很單純
  - 頻繁互動: 元件間需要大量來回
```

**範例：多媒體工具鏈分解重組**

```yaml
原始工具集:
  - FFmpeg: 視頻/音頻處理
  - ImageMagick: 圖片處理
  - Pandoc: 文檔轉換
  - yt-dlp: 視頻下載

分解後的元件:
  格式轉換元件:
    - video-convert (FFmpeg 子集)
    - audio-convert (FFmpeg 子集)
    - image-convert (ImageMagick 子集)
    - doc-convert (Pandoc 子集)

  下載元件:
    - video-download (yt-dlp)
    - audio-download (yt-dlp + FFmpeg)

  優化元件:
    - video-compress (FFmpeg)
    - image-optimize (ImageMagick)

重組成統一 Skill:
  media-toolkit:
    - 「把這個 X 變成 Y」→ 自動路由到對應元件
    - 「下載這個視頻的音頻」→ 串接下載 + 轉換
    - 「壓縮這批圖片」→ 批次處理 + 進度回報
```

### 📚 封裝即學習

> **封裝開源項目的過程，本身就是最好的學習方式**

```
┌─────────────────────────────────────────────────────────────────┐
│  封裝過程中會獲得的知識                                         │
│                                                                 │
│  閱讀 README     →  了解項目目的和核心概念                      │
│  分析代碼結構    →  學習架構設計和最佳實踐                      │
│  理解參數        →  掌握領域專業知識                            │
│  處理錯誤        →  知道邊界情況和限制                          │
│  撰寫 Skill      →  用自己的話重新表達（Feynman 驗證）          │
│                                                                 │
│  💡 不只是「包裝」，而是「消化吸收後重新輸出」                  │
└─────────────────────────────────────────────────────────────────┘
```

**知識萃取範例**：

| 項目 | 封裝過程學到的知識 |
|------|-------------------|
| FFmpeg | 視頻編碼原理、容器格式、碼率控制、硬體加速 |
| Qiskit | 量子位、疊加態、量子閘、量子電路、測量 |
| yt-dlp | 視頻平台 API、反爬蟲機制、格式選擇策略 |
| ComfyUI | SD 原理、採樣器、LoRA、ControlNet |
| Pandas | 數據結構、向量化操作、記憶體優化 |

**學習驅動的封裝策略**：

```yaml
目標: 學習量化交易
步驟:
  1. 選擇項目: backtrader 或 zipline
  2. 封裝核心概念:
     - 策略定義 → 學習技術指標
     - 回測引擎 → 學習模擬機制
     - 風險管理 → 學習資金管理
  3. 產出 Skill: quant-trading
  4. 副產品: 獲得量化交易完整知識體系

→ 封裝完成 = 知識內化完成
```

### 🎨 UX 改善封裝技巧

> **即使工具功能完整，只要 UX 可以更好，就值得封裝**

| 原始痛點 | 封裝後體驗 | 範例 |
|----------|------------|------|
| 參數地獄 `-c:v libx264 -crf 23 -preset medium` | 「用中等品質轉換」 | FFmpeg |
| 多步驟流程 | 「一句話完成」 | 下載 → 轉換 → 壓縮 |
| 錯誤訊息難懂 | 友善的解釋 + 建議修正 | 各種 CLI 工具 |
| 輸出格式混亂 | 結構化、美觀的結果 | 數據分析工具 |
| 沒有進度顯示 | 即時進度回報 | 長時間任務 |
| 不知道怎麼開始 | 互動式引導 | 複雜配置工具 |

**UX 封裝的核心思想**：

```
原始工具           Skill 封裝           使用者
  │                  │                   │
  │  複雜的 CLI      │  自然語言介面     │  簡單的意圖
  │  難懂的參數      │  智能默認值       │  「幫我 XX」
  │  晦澀的輸出      │  友善的結果       │  看得懂的回應
  │                  │                   │
  └──────────────────┴───────────────────┘
         Skill = 翻譯層 + 優化層
```

## 決策流程圖

```
┌─────────────────────────────────────────────────────────────────┐
│  GitHub → Skill 封裝決策（務實版）                              │
│                                                                 │
│  1. 🎯 快速六維度檢查                                           │
│     「這個工具封裝後能否：                                      │
│       ⚡ 省時？ 🎓 增專業？ 🔧 更完整？ ✨ 更好？ 🎨 更好用？ 📚 學到？」│
│     ├─ 全否 → 直接讓 AI 執行，不封裝                            │
│     └─ 任一是 → 繼續                                            │
│                                                                 │
│  2. Skill 庫已有類似功能嗎？                                    │
│     ├─ 是 → 優先使用現有 Skill，考慮擴展                        │
│     └─ 否 → 繼續                                                │
│                                                                 │
│  3. 這個工具主要是命令行/腳本操作嗎？                           │
│     ├─ 否（需要 GUI）→ 考慮 MCP Server 或操作指引               │
│     └─ 是 → 繼續                                                │
│                                                                 │
│  4. 專案是否活躍維護？（近 6 個月有更新）                       │
│     ├─ 否 → 謹慎評估，可能有未修復的 bug                        │
│     └─ 是 → ✅ 適合封裝                                         │
│                                                                 │
│  → 進入封裝流程                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 決策範例

```yaml
案例 1: FFmpeg 視頻轉換
  ⚡ 省時: 是 - 不用每次查參數
  🎓 專業: 是 - 編碼知識內建
  🔧 完整: 是 - 整合常用格式
  ✨ 品質: 是 - 統一入口更好用
  🎨 體驗: 是 - 自然語言取代參數地獄
  📚 學習: 是 - 理解視頻編碼原理
  → 6/6 ✅ 強烈建議封裝

案例 2: 某個只用一次的腳本
  ⚡ 省時: 否 - 就用一次
  🎓 專業: 否 - 沒有學習價值
  🔧 完整: 否 - 功能單一
  ✨ 品質: 否 - 不需要改進
  🎨 體驗: 否 - 用完即棄
  📚 學習: 否 - 沒什麼可學
  → 0/6 ❌ 不需要封裝

案例 3: ComfyUI 工作流
  ⚡ 省時: 是 - 節點配置複雜
  🎓 專業: 是 - 需要了解 SD 原理
  🔧 完整: 是 - 可整合多種功能
  ✨ 品質: 是 - 原生介面不夠直覺
  🎨 體驗: 是 - 「生成 XX 風格圖片」比拖節點友善
  📚 學習: 是 - 深入理解 Stable Diffusion
  → 6/6 ✅ 強烈建議封裝

案例 4: Git CLI（已經很好用的工具）
  ⚡ 省時: 否 - 命令已經很簡潔
  🎓 專業: 否 - 大家都會
  🔧 完整: 否 - 功能已完整
  ✨ 品質: 否 - 很成熟
  🎨 體驗: 是 - 可以做成「幫我提交這些變更」
  📚 學習: 否 - 沒有新知識
  → 1/6 🔶 可選封裝（只為 UX）

案例 5: Qiskit 量子計算框架（純學習目的）
  ⚡ 省時: 否 - 不會常用
  🎓 專業: 是 - 量子計算是新領域
  🔧 完整: 否 - 只是學習
  ✨ 品質: 否 - 不是主要目的
  🎨 體驗: 否 - 學習為主
  📚 學習: 是 - 量子位、量子閘、測量原理
  → 2/6 🔶 可選封裝（學習驅動）
  💡 封裝過程 = 最好的學習方式
```

## 封裝流程

### Phase 1: 評估（10 分鐘）

```yaml
評估清單:
  基本資訊:
    - [ ] GitHub URL
    - [ ] Stars 數量（建議 > 1k 為佳）
    - [ ] 最後更新時間
    - [ ] 主要語言

  功能評估:
    - [ ] 核心功能是什麼？
    - [ ] 我需要的是哪些功能？（通常只需要 20%）
    - [ ] 有無 CLI 介面？

  依賴評估:
    - [ ] 需要什麼環境？（Python、Node、Docker...）
    - [ ] 有無複雜的系統依賴？
    - [ ] 安裝難度如何？
```

### Phase 2: 規劃（5 分鐘）

使用 skill-creator 或 OpenCode Plan 模式：

```
Prompt 範本:
「幫我把這個開源工具：[GitHub URL]
打包成一個 Skill，只要我後續給出 [使用情境描述]，
就可以幫我 [期望結果]。」

例如:
「幫我把這個開源工具：https://github.com/yt-dlp/yt-dlp
打包成一個 Skill，只要我後續給出視頻鏈接，
就可以幫我下載視頻。」
```

### Phase 3: 配置訪談

AI 會詢問你幾個關鍵問題，建立個人化配置：

```yaml
常見配置項:
  路徑設定:
    - 下載路徑 / 輸出路徑
    - 暫存目錄

  格式偏好:
    - 默認輸出格式
    - 品質設定

  行為偏好:
    - 覆蓋 / 跳過已存在
    - 是否保留中間檔案

  認證資訊:
    - API Key（如需要）
    - Cookie 路徑（如需要）
```

### Phase 4: 生成與測試

```
1. AI 生成 Skill 文件
   └─ SKILL.md（或 skill.py）

2. 首次運行測試
   └─ 用簡單案例驗證

3. 遇到問題 → AI 自動修正 → 更新 Skill
   └─ 這是關鍵！Skill 會自我進化

4. 驗證成功 → 安裝到本地
```

### Phase 5: 迭代優化

```
使用過程中遇到問題：

例如：YouTube 防爬需要 Cookie

1. AI 指導你解決問題
2. 詢問：「要不要把這個經驗更新到 Skill 裡？」
3. 確認後自動更新 Skill 文件
4. 下次遇到同樣情況會自動處理

→ Skill 從經驗中學習，越用越好
```

## 模型選擇建議

| 階段 | 建議模型 | 原因 |
|------|---------|------|
| **構建 Skill** | Claude Opus 4.5 | 需要深度理解代碼和文檔 |
| **規劃階段** | Claude Opus / Sonnet | 需要架構思考 |
| **運行 Skill** | GPT Codex / Claude Sonnet | 執行快、成本低 |
| **簡單任務** | Claude Haiku | 最快最便宜 |

## 與 evolve 整合

### 觸發時機

在 evolve 的 **skill-acquisition** 流程中：

```
Level 1: Skill + Memory（正常路徑）
         ↓ 找不到
Level 2: 外部知識源
         ├─ context7 查詢文檔
         ├─ Web 搜尋最佳實踐
         └─ 🆕 詢問：「是否要封裝 GitHub 項目為 Skill？」

觸發條件：
  - 任務涉及特定工具/庫
  - 搜尋結果指向 GitHub 項目
  - 預期會重複使用
```

### 新增 Flag

```bash
# 直接從 GitHub 封裝
/evolve --from-github https://github.com/yt-dlp/yt-dlp

# 流程：
# 1. 分析 README 和文檔
# 2. 識別核心功能
# 3. 配置訪談
# 4. 生成 Skill
# 5. 測試驗證
# 6. 安裝到本地
```

### 產出對接

| 封裝產出 | 對應位置 |
|---------|---------|
| Skill 文件 | `.claude/skills/[name]/SKILL.md` |
| 配置記錄 | `.claude/memory/config/[name].md` |
| 使用經驗 | `.claude/memory/learnings/` |
| 失敗經驗 | `.claude/memory/failures/` |

## 實戰案例

### 案例 1: video-downloader（基於 yt-dlp）

```yaml
背景: 經常需要下載 YouTube/B站 視頻

封裝前:
  - 每次都要查 yt-dlp 參數
  - 忘記下載路徑設定
  - 遇到防爬不知道怎麼處理

封裝後:
  - 「幫我下載這個視頻」→ 自動處理
  - 默認存到 ~/Downloads/Videos
  - 遇到防爬自動提示添加 Cookie

Skill 自我進化:
  - 首次: 基本下載功能
  - 迭代 1: 添加 Cookie 支持（遇到 YouTube 防爬）
  - 迭代 2: 添加 B站 支持（發現需要不同參數）
  - 迭代 3: 添加字幕下載（用戶新需求）
```

### 案例 2: format-converter（基於多個工具）

```yaml
背景: 經常需要轉換各種格式

整合工具:
  - Pandoc: 文檔轉換
  - ImageMagick: 圖片轉換
  - FFmpeg: 視頻/音頻轉換
  - SheetJS: Excel 處理

封裝策略:
  - 統一入口：「把 X 轉成 Y」
  - 自動識別輸入格式
  - 自動選擇合適的工具
  - 一個 Skill 解決所有格式轉換

成果:
  「把這個 PDF 轉成 Word」→ Pandoc
  「把這張圖片轉成 WebP」→ ImageMagick
  「把這個視頻轉成 MP3」→ FFmpeg
```

### 案例 3: pake（網頁打包桌面 APP）

```yaml
背景: 想把常用網頁變成桌面應用

項目: github.com/tw93/Pake (45k stars)

封裝價值:
  - 不需要了解 Rust/Tauri
  - 一句話：「把 [URL] 打包成桌面 APP」
  - 自動處理圖標、名稱、配置

使用場景:
  - 把 ChatGPT 網頁版變成桌面 APP
  - 把常用工具網站變成獨立應用
```

## 避坑指南

### 常見問題

| 問題 | 原因 | 解法 |
|------|------|------|
| 安裝失敗 | 系統依賴缺失 | Skill 中加入環境檢查 |
| 運行報錯 | 參數格式變了 | 定期更新 Skill |
| 功能受限 | 封裝太簡化 | 保留常用參數暴露 |
| 效能差 | 每次都重新初始化 | 考慮持久化狀態 |

### 最佳實踐

1. **只封裝你需要的** - 不要試圖封裝整個項目的所有功能
2. **保持 Skill 簡單** - 一個 Skill 做好一件事
3. **留有擴展空間** - 允許傳入自定義參數
4. **記錄經驗** - 遇到問題就更新 Skill
5. **定期維護** - 上游更新後檢查相容性

## 相關資源

- [skill-creator](../../skill-creator/SKILL.md) - 創建新 Skill 的指南
- [skill-acquisition](../../01-core/_base/skill-acquisition.md) - 技能習得流程
- [knowledge-acquisition](./knowledge-acquisition.md) - 4C 學習方法

---

*靈感來源: [数字生命卡兹克 - Skills 的最正確用法](https://x.com/Khazix0918/status/2013812311388229792)*
